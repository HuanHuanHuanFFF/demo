# JWT_Why_Single_Token_Not_Enough

## TL;DR
- 只用 access 想同时“安全 + 体验”很难：短 TTL 安全但频繁掉线；长 TTL 体验好但被盗窗口太大。
- “把 access 做成长期且可撤回”当然能做，但代价是：每个业务请求都要查服务端状态，成本/复杂度上升。
- 所以需要把“业务访问”和“续期/撤销”拆开：业务票据保持轻量短命，续期能力独立出来并可控。

## 核心概念
- **access 的两难**：
  - TTL 短：安全✅（被盗只能用一小会儿），体验❌（经常过期）。
  - TTL 长：体验✅，安全❌（被盗能用很久，且 JWT 天生难“收回”）。
- **为什么不把 access 做成长期可撤回？**
  - 需要“服务端记账”：要撤回就得记录 token 标识（jti/版本号/会话）并查询。
  - 业务接口每次请求都要查 Redis/DB：QPS (Queries Per Second/每秒请求数)  上来后成本高，还要处理“缓存挂了怎么办/并发一致性/清理策略”。
  - 最终会把“无状态 JWT”变回“有状态会话”，但实现更复杂。
- **正确拆分的方向**：
  - 让业务访问继续走“轻量校验”（验签+过期）；
  - 把“续期/撤销”放到一条专门链路里做（这样才能既不拖慢业务请求，又能随时让续期失效）。

## 常见追问
- Q：我只用短 access 不就够安全吗？  
  A：安全更好，但体验会很差：10–30min 就过期，用户会频繁掉线/频繁重新登录。  
- Q：那把 access TTL 拉长不就好了？  
  A：一旦泄露，攻击窗口会变得很大，而且 JWT 本身难撤回，风险不可控。  
- Q：为什么不把 access 做成长期且可撤回？  
  A：可以做，但每个业务请求都要查服务端状态（Redis/DB），成本高、复杂度也高。  
- Q：那怎么同时做到“体验好”又“风险可控”？  
  A：把“续期能力”独立出来，且让它能被服务端控制与撤销；业务访问则保持短命轻量。  
  → [[JWT_RefreshToken]]

## 关联链接
- [[JWT_RefreshToken]]